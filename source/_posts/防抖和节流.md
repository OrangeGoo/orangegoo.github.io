---
title: 防抖和节流
categories: 
- 前端优化
tags: 
- 学习笔记
---
# 一.防抖和节流是什么
本质上是优化高频率执行代码的一种手段。
如：浏览器的resize、scroll、keypress、mousemove等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能
为了优化体验，需要对这类事件进行调用次数的限制，对此我们可以采用debounce（节流）和throttle（防抖）的方式来减少调用频率。

**定义：**
* 节流：n秒内只运行一次，若在n秒内重复触发，只有一次生效
* 防抖：n秒后再执行该事件，若在n秒内被重复触发，则重新计时

**一个经典的比喻：**
想象每天上班大厦底下的电梯，把电梯完成一次运送，类比为一次函数的执行和响应，
假设电梯有两种运行策略debounce和throttle，超时设定15秒，不考虑容量限制，
电梯一个人进来后，15秒后准时运送一次，这是节流；
电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时直到15秒后开始运送，这是防抖。

# 二.防抖
防抖的策略是当事件触发时，设定一个周期延迟执行动作，若期间又被触发，则重新设定周期，直到周期结束，执行动作。这是debounce的基本思想，在后期又扩展了前缘debounce，即执行动作在前，然后设定周期，周期内有事件被触发，不执行动作，且周期重新设定。

**延迟debounce：**
<img src="https://img-blog.csdnimg.cn/d8e87c76b0f342cc8be7a0666792cccc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5ZCJ5Yay5Yay5Yay,size_20,color_FFFFFF,t_70,g_se,x_16">
**前缘debounce：**
<img src="https://img-blog.csdnimg.cn/4822bcbae76c4c72897f27f22c557ef7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5ZCJ5Yay5Yay5Yay,size_20,color_FFFFFF,t_70,g_se,x_16">

debounce的特点是当事件触发快速连续不断触发时，动作只会执行一次，延迟debounce，是在周期结束时执行，前缘debounce，在周期开始时执行，但当触发有间断，且间断大于我们设定的时间间隔时，动作就会有多次执行。

debounce的实现：
版本1:周期内有新事件触发，清除旧定时器，重置新定时器；这种方法，需要高频的创建定时器。

```javascript
// 暴力版：定时器期间，有新操作时，清除旧定时器，重设新定时器
var debounce = (fn, wait) => {
  let timer, timeStamp = 0
  let context, args
  let run = () => {
    timer = setTimeout(() => {
      fn.apply(context, args)
    }, wait)
  }
  let clean = () => {
    clearTimeout(timer)
  }
 	return function() {
    context = this
    args = arguments
    let now = Date().now
    if(now - timeStamp < wait) {
      console.log('reset',now)
      clean()
      run()
    }else{
      console.log('set',now)
      run()
    }
    timeStamp = now
  }
}
```

版本2:周期内有新事件触发时，重置定时器开始时间戳，定时器执行时，判断开始时间戳，若开始时间戳被推后，重新设置延时定时器。

```javascript
// 优化版：定时器执行期间，判断start time是否向后推迟了，若是，设置延时定时器
var debounce = (fn, wait) => {
  let timer, startTimeStamp = 0
  let context, args
  let run = (timeInterval) => {
     timer = setTimeout(()=>{
       let now = Date().now
       let interval = now - startTimeStamp
       if(interval < timeInterval) {
         console,log('debounce set',timeInterval - interval)
         startTimeStamp = now
         run(wait - interval)
       }else{
         fn.apply(context,args)
         clearTimeout(timer)
         timer = null
       }
     },timeInterval)
  }
  return function(){
    context = this
    args = arguments
    let now = Date().now
    startTimeStamp = now
    if(!timer) {
      console.log('debounce set',wait)
      run(wait)
    }
  }
}
```

```javascript
// 增加前缘触发功能
var debounce = (fn, wait, immediate) => {
  let timer, startTimeStamp = 0
  let context, args
  let run = (timeInterval) => {
    timer = setTimeout(() => {
      let now = Date().now
      let interval = now - startTimeStamp
      if(interval < timeInterval) {
        console.log('debounce set',timeInterval - interval)
        startTimeStamp = now
        run(wait - interval)
      }else{
        if(!immediate) {
          fn.apply(context, args)
        }
        clearTimeout(timer)
        timer = null
      }
    }, timeInterval)
  }
  return function(){
    context = this
    args = arguments
    let now = Date().now
    startTimeStamp = now
    if(!timer) {
      console.log('debounce set', wait)
      if(immediate) {
        fn.apply(context, args)
      }
      run(wait)
    }
  }
}
```

# 三.节流
throttling,节流的策略是，固定周期内，只执行一次动作，若有新事件触发，不执行。周期结束后，又有新事件触发，开始新的周期。节流策略也分为前缘和延迟两种。与debounce类似，延迟是指周期结束后执行动作，前缘是指执行动作后再开始周期。

**延迟throttling示意图：**
<img src="https://img-blog.csdnimg.cn/97a33cd2ded7478fb7a184d3d4a06825.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5ZCJ5Yay5Yay5Yay,size_20,color_FFFFFF,t_70,g_se,x_16">
**前缘throttling示意图：**
<img src="https://img-blog.csdnimg.cn/da4a25bef9044786b328dbeb67a55e26.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5ZCJ5Yay5Yay5Yay,size_20,color_FFFFFF,t_70,g_se,x_16">

throttling的特点是在连续高平触发事件时，动作会被定期执行，响应平滑。
throttling的实现：

```javascript
//简单版：定时器期间，只执行最后一次操作
var throttling = (fn, wait) => {
  let timer, timerStamp = 0
  let context, agrs
  let run = () => {
    timer = setTimeout(()=>{
      fn(context, agrs)
      clearTimeout(timer)
      timer = null
    },wait)
  }
  return function(){
    context = this
    args = arguments
    if(!timer){
      console.log('throttling,set')
      run()
    }else{
      console.log('throttling,ignore')
    }
  }
}
```

```javascript
//增加前缘
var throttling = (fn, wait, immediate) => {
  let timer, timeStamp = 0
  let context, args
  let run = () => {
    timer = setTimeout({
      if(!immediate) {
        fn.apply(context,args)
      }
      clearTimeout(timer)
    	timer = null
    },wait)
  }
    return function(){
    context = this
    args = arguments
    if(!timer) {
      console.log('throttling,set')
      if(immediate) {
      	fn.apply(context, args)
      }
      run()
    }else{
        console.log('throttling,ignore')
      }
    }
}
```

debounce和throttling各有各的特点，在不同的场景要根据需求合理地选择策略。如果事件触发是高频但是有停顿时，可以选择debounce；在事件连续不断高频触发时，只能选择throttling，因为debounce可能会导致动作只被执行一次，界面出现跳跃。