---
title: 浏览器相关知识
categories: 
- 浏览器
tags: 
- 学习笔记
---
# 从输入URL到页面加载的全过程
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e44aa8a92602405db3c12161b71e2094~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"/>

1. 首先在浏览器中输入url。
2. 查找缓存：浏览器首先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容，如果没有则进行下一步。
	* 浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；
	* 操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录（保存最近的DNS查询缓存）；
	* 路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；
	* IPS缓存：若上述均失败，继续向IPS搜索。
3. DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。
4. 建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接。
5. 发起HTTP请求：浏览器发起读取文件的HTTP请求，该请求报文作为TCP三次握手的第三次数据发送给服务器。
6. 服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器。
7. 关闭TCP连接：通过四次挥手释放TCP连接。
8. 浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：
    * 构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象
    * 构建CSS规则树：生成CSS规则树（CSS Rule Tree） 
    * 构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）
    * 布局（Layout）：计算出每个节点在屏幕中的位置
    * 绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a90660027f0d4c559732519bad4c6323~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">

9. JS引擎解析过程：调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链，回收机制等）
    * 创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的document对象上，当关闭网页或关闭浏览器时，全局执行环境会被销毁。
    * 加载文件：完成js引擎分析它的词法和语法是否合法，如果合法进入预编译。
    * 预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为'undefined'；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。
    * 解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就成为全局变量。String、Int这样的值就是直接把值放在变量的存储空间里，Object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的。

# 浏览器重绘与重排
* 重排/回流（Reflow）：当DOM的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中正确的位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。
* 重绘（Repaint）：当一个元素的外观发生改变，但没有改变布局，重新要把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变。
**单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排后，将会重新绘制受到此次重排影响的部分**
**重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。**
*重绘不一定出现重排，重排一定出现重绘*
## 如何触发重排和重绘？
任何改变用来构建渲染树的信息都会导致一次重排或重绘：
  * 添加、删除、更新DOM节点
  * 通过display：none隐藏一个DOM节点-触发重排或重绘
  * 通过visibility：hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化
  * 移动或者给页面中的DOM节点添加动画
  * 添加一个样式表，调整样式属性
  * 用户行为，例如调整窗口大小，改变字号，或者滚动
## 如何避免重绘或重排？
1. 集中改变样式：不要一条条地修改DOM的样式
2. 不要把DOM结点的属性值放在循环里当成循环里的变量
3. 为动画的HTML元件使用fixed或absolute的position，那么修改他们的CSS是不会reflow的。
4. 不使用table布局。因为可能很小的改动会造成整个table的重新布局
5. 尽量只修改position：absolute或fixed的元素，对其他元素影响不大
6. 动画开始GPU加速，translate使用3D变化
7. 提升为合成层
    将元素提升为合成层有以下优点：
      * 合成层的位图，会交由GPU合成，比CPU处理要快
      * 当需要repaint时，只需要repaint本身，不会影响到其他层
      * 对于transform和opacity效果，不会触发layout和paint
    提升合成层的最好方式是使用CSS地will-change属性：
    ``` CSS
    #target {
      will-change: transform;
    }
    ```
# 彻底理解浏览器的缓存机制
## 概述
浏览器的缓存机制也就是我们所说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的，所以在分析浏览器缓存机制之前，先用图文简单介绍一下HTTP报文，HTTP报文分为两种：

HTTP请求（request）报文，报文格式为：请求行 - HTTP头（通用信息头、请求头、实体头）- 请求报文主体（只有POST才有报文主体），如下图
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55ac73a4b8514981bd4e3c203b82a488~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">

HTTP响应（Response）报文，报文格式：状态行 - HTTP头（通用信息头、响应头、实体头）- 响应报文主体，如下图
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0902274150584642a0b80391906493e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">

## 为什么需要浏览器缓存？
我们知道通过HTTP协议，在客户端和浏览器建立连接时需要消耗时间，而大的响应需要在客户端和服务器之间进行多次往返通信才能获得完整的响应，这拖延了浏览器可以使用和处理内容的时间。这就增加了访问服务器的数据和资源的成本，因此利用浏览器的缓存机制重用以前获取的数据就变成了性能优化时需要考虑的事情。

## 缓存过程分析
浏览器与服务端通信的方式为应答模式，即是：浏览器发起HTTP请求 - 服务器响应该请求，那么浏览器第一次向服务器发起请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b17768a75f724f34b3293557a7221c43~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">

由上图我们可以知道：
  * 浏览器每次发起请求，都会**先在浏览器缓存中查找该请求的结果以及缓存标识**
  * 浏览器每次拿到返回的请求结果都会**将该结果和缓存标识存入浏览器缓存中**
以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是**强制缓存**和**协商缓存**。

## 强制缓存
**强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。**
强制缓存的情况主要有三种（暂不分析协商缓存过程），如下：
  1. 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：
  <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/895df2317f63433789d7679966c2dfd2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">

  2. 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失败，则使用协商缓存(下面再分析)，如下图：
  <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e630de0f8402488db251db6416519aa4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">

  3. 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图：
  <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f66cb26bdefc4b5ca78679a5684ad842~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">

  **那么强制缓存的规则是什么？**
  当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。

  **Expires**
  Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。
  到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同，客户端和服务端有一方的时间不精确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义。

  **Cache-Control**
  在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：
  * public：所有内容都将被缓存（客户端和代理服务器都可缓存）
  * private：所有内容都只有客户端可以缓存，Cache-Control的默认取值
  * no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
  * no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
  * max-age=xxx（xxx is numeric）：缓存内容将在xxx秒后失效

接下来，我们直接看一个例子，如下：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4f5a25abebf44e89fe2cc88f58888ae~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">

由上面的例子我们可以知道：
* HTTP响应报文中的expires的时间值，是一个绝对值
* HTTP响应报文中的Cache-Control为max-age=600，是相对值

由于Cache-Control的优先级比Expires高，那么直接根据Cache-Control的值进行缓存，意思就是说在600秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。

注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于Expires是更好的选择，所以同时存在时，只有Cache-Control生效。

了解强制缓存的过程后，我们拓展性地思考一下：
**浏览器的缓存放在哪里，如何在浏览器中判断强制缓存是否生效？**
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b66d0192c764abeb5f5a46f07478eeb~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">

这里我们以博客的请求为例，状态码为灰色的请求则代表使用了强制缓存，请求对应的Size值则代表该缓存存放的位置，分别为from memory cache和from disk cache
from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory -> disk
* 内存缓存：内存缓存具有两个特点，分别是快速读取和时效性：
    * 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行时的快速读取。
    * 时效性：一旦该进程关闭，则该进程的内存则会清空。
* 硬盘缓存：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓慢。

在浏览器中，浏览器会在js和图片等文件解释执行后直接存入内存缓存中，那么当刷新页面时只需要从内存缓存中读取；而CSS文件则会存入硬盘，所以每次渲染页面都要从硬盘读取缓存。

## 协商缓存
**协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程**，主要有一下两种情况：
协商缓存生效，返回304，如下：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de27583c85ea40369d25289de078841d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">

协商缓存失效，返回200和请求结果，如下：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19ef7242d4af419db748aef552494c19~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">

同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified/If-Modified-Since和Etag/If-None-Match，其中Etag/If-None-Match的优先级比Last-Modified/If-Modified-Since高。

**Last-Modified/If-Modified-Since**
Last-Modified是服务器响应请求时，返回**该资源文件在服务器最后被修改的时间**。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7fc72150fa64d02ae4144cabe92d214~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">

If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码200；否则返回304，代表资源无更新，可继续使用缓存文件
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27ee80ddeaec46ec82eb08db332787f1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">

Etag/If-None-Match
Etag是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成）
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dba1ca243be64ae7bc43b3bcd609561f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">

**Etag的工作原理**
如上图，服务器在第一次返回响应的时候设置了缓存的时间120s，假设浏览器在这120s经过之后再次请求服务器相同的资源，首先，浏览器会检查本地缓存并找到之前的响应，不幸的是，这个响应现在已经'过期'，无法再使用。此时，浏览器也可以直接发出新请求，获取新的完整响应，但是这样效率较低，因为如果资源未被更改过，我们就没有理由再去下载与缓存中已有的完全相同的字节。

于是就到了Etag发挥作用的时候了，通常服务器生成并返回在Etag中的验证码，常常是文件内容的哈希值或者某个其他指纹码。客户端不必了解指纹码是如何生成的，只需要在下一个请求中将其发送给服务器（浏览器默认会添加）；如果指纹码仍然一致，说明资源未被修改，服务器会返回304 Not Modified，这样我们就可以跳过下载，利用已经缓存了的资源，并且该资源会继续缓存120s。

**If-None-Match**是客户端再次发起请求时，携带上次请求返回的唯一标识Etag值，通过此字段告诉服务器该资源上次请求返回的唯一标识。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态为200。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/132a26f7446444ce894bdeea143d4ad8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">

**总结**
浏览器缓存分为**强制缓存**和**协商缓存**，强制缓存优先于协商缓存进行。
* 若强制缓存(Expires和Cache-Control,Cache-Control优先级高于Expires)生效则直接使用缓存
* 若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高)，协商缓存由服务器决定是否使用缓存
* 若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存

主要过程如下：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd83f74914f14a0c8f007cf343c2bcbf~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">

